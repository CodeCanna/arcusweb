/**
 * Copyright 2019 Arcus Project
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import _ from 'lodash';
import $ from 'jquery';
import Component from 'can-component';
import canMap from 'can-map';
import canList from 'can-list';
import each from 'can-util/js/each/each';
import canDev from 'can-util/js/dev/';
import isArrayLike from 'can-util/js/is-array-like/';
import 'can-map-define';
import 'can-stache-converters';
import SidePanel from 'i2web/plugins/side-panel';
import 'semantic-ui-dropdown-canjs';
import 'i2web/helpers/attributes';
import 'i2web/helpers/form-fields';
import isTouchscreen from 'i2web/plugins/is-touchscreen';

const USE_TOUCH = isTouchscreen();

// validation
import validate from 'validate.js';
import cardValidator from 'card-validator';

validate.validators.oneLetterOneNumber = (value) => {
  if (value && (!value.match(/\d+/g) || !value.match(/[A-Za-z_]+/g))) {
    return 'must have at least 1 letter and 1 number';
  }
  return undefined;
};

validate.validators.noSpaces = (value) => {
  if (value && value.indexOf(' ') !== -1) {
    return 'cannot use spaces';
  }
  return undefined;
};

validate.validators.cardNumber = (value) => {
  if (value && !cardValidator.number(value).isValid) {
    return 'must be valid';
  }
  return undefined;
};

validate.validators.phoneNumber = (value) => {
  if (value && (value.match(/\d/g) || []).length !== 10) {
    return 'must be a valid phone number';
  }
  return undefined;
};

if (System.isEnv('production')) {
  // The errors being generated by this are not correct, surpress them as the
  // errors suggest we should do.
  $.fn.transition.settings.silent = true;
}

// if using IE11 synthesize a change event. used since IE is bad at knowing when to fire it
const synthesizeIEChangeEvent = window.navigator.userAgent.indexOf('Trident/7.0') > 0
  ? (el) => {
    const event = document.createEvent('Event');
    event.initEvent('change', true, false);
    el.dispatchEvent(event);
  }
  : () => {};


export const FormViewModel = canMap.extend({
  define: {
    /**
     * @property {canMap} _visited
     * @parent i2web/components/form
     *
     * @description Has the field been visited before?
     */
    _visited: {
      Type: canMap,
      value: {},
    },
    /**
     * @property {canMap} _changed
     * @parent i2web/components/form
     *
     * @description Has the field been visited before?
     */
    _changed: {
      Type: canMap,
      value: {},
    },
    /**
     * @property {canMap} _validationErrors
     * @parent i2web/components/form
     *
     * @description Form errors, keyed by field name
     */
    _validationErrors: {
      Type: canMap,
      value: {},
    },
    /**
     * @property {canList} _requiredFields
     * @parent i2web/components/form
     *
     * @description Required fields on the form
     */
    _requiredFields: {
      get() {
        const fields = new canList([]);
        each(this.attr('constraints').serialize(), (constraint, key) => {
          if (constraint.presence) fields.push(key);
        });
        return fields;
      },
    },
    /**
     * @property {canMap} _equalityRelations
     * @parent i2web/components/form
     *
     * @description Mapping of fields with validation depending on equality with another field
     */
    _equalityRelations: {
      get() {
        const equalityRelations = new canMap({});
        each(this.attr('constraints').serialize(), (constraint, key) => {
          if (constraint.equality) {
            let attributeRelations = equalityRelations.attr(constraint.equality.attribute);
            if (!isArrayLike(attributeRelations)) attributeRelations = [];
            attributeRelations.push(key);
            equalityRelations.attr({ [constraint.equality.attribute]: attributeRelations }, false);
          }
        });
        return equalityRelations;
      },
    },
    /**
     * @property {Array} _constrainedFields
     * @parent i2web/components/form
     *
     * @description Array of all fields with constraints
     */
    _constrainedFields: {
      get() {
        return canMap.keys(this.attr('constraints'));
      },
    },
    /**
     * @property {boolean} _anyFieldHasChanges
     * @parent i2web/components/form
     *
     * @description Whether anything has changed on the form
     * Note: this includes changing a field's value and then resetting it
     */
    _anyFieldHasChanges: {
      type: 'boolean',
      value: false,
    },
    /**
     * @property {object} firstInvalidField
     * @parent i2web/components/form
     *
     * @description Name of first form field containing validation errors; returns undefined if none
     */
    firstInvalidField: {
      get() {
        const fieldsWithErrors = canMap.keys(this.attr('_validationErrors'));
        if (fieldsWithErrors.length) {
          return fieldsWithErrors[0];
        }
        return undefined;
      },
    },
    /**
     * @property {canMap} constraints
     * @parent i2web/components/form
     *
     * @description Form validation constraints, keyed by field name
     */
    constraints: {
      Type: canMap,
      value: {},
    },
  },
  /**
   * @function _convertFieldNameToDotNotation
   * @parent i2web/components/form
   * @description Converts any fields using bracket notation back to dot notation to match constraints
   */
  _convertFieldNameToDotNotation(name = '') {
    const parts = name.replace(/]/g, '').replace(/'/g, '').split('[');
    const rootField = parts.shift();
    return `${rootField}${(rootField && parts.length) ? '.' : ''}${parts.join('.')}`;
  },
  /**
   * @property {String} formError
   * @parent i2web/components/form
   *
   * @description A form error
   */
  formError: null,
  /**
   * @function formValidates
   * @parent i2web/components/form
   * @param {Array<string>} [fields] (optional)
   * @description Validates all (or specified) fields on the VM
   */
  formValidates(fields = []) {
    this.validate(fields);
    return !this.hasValidationErrors(fields);
  },
  /**
   * @function hasConstraints
   * @parent i2web/components/form
   * @description Whether a field has constraints on it
   */
  hasConstraints(field) {
    return this.attr('_constrainedFields').includes(field);
  },
  /**
   * @function validate
   * @parent i2web/components/form
   * @param {Array<string>} [fields] (optional)
   * @description Validates all (or specified) fields on the VM with constraints
   */
  validate(fields = []) {
    // get a list of all fields with constraints, and retrieve their values
    const constraints = this.attr('constraints').serialize();
    const values = {};
    this.attr('_constrainedFields').forEach((attr) => {
      values[attr] = this.attr(attr);
    });

    if (fields instanceof canList) {
      fields = fields.attr(); // eslint-disable-line no-param-reassign
    }
    if (Array.isArray(fields) && fields.length) {
      const filteredConstraints = {};
      const filteredValues = {};
      each(constraints, (constraint, key) => {
        if (fields.includes(key)) {
          // escape . properties
          filteredConstraints[key.replace(/\./g, '\\.')] = constraint;
        }
      });
      each(values, (value, key) => {
        if (fields.includes(key)) {
          filteredValues[key] = value;
        }
      });
      const errors = validate(filteredValues, filteredConstraints);
      fields.forEach((field) => {
        // unescape dot properties
        if (errors && errors.hasOwnProperty(field.replace(/\./g, '\\.'))) {
          // TODO remove replacement when . supported
          this.attr('_validationErrors').attr(field.replace(/\./g, '__'), errors[field.replace(/\./g, '\\.')]);
        } else {
          // TODO remove replacement when . supported
          this.attr('_validationErrors').removeAttr(field.replace(/\./g, '__'));
        }
      });
    } else {
      // escape . constraints
      each(constraints, (value, key) => {
        // escape equality attribute names
        if (value.equality) {
          value.equality.attribute = value.equality.attribute.replace(/\./g, '\\.');
        }
        // escape keys
        if (key.includes('.')) {
          constraints[key.replace(/\./g, '\\.')] = value;
          delete constraints[key];
        } else {
          constraints[key] = value;
        }
      });

      const errors = validate(values, constraints) || {};
      each(errors, (error, key) => {
        if (key.includes('\\.')) {
          // TODO remove replacement when . supported
          errors[key.replace(/\\./g, '__')] = error;
          delete errors[key];
        }
      });
      this.attr('_validationErrors', errors);
    }
  },
  /**
   * @function validateSingle
   * @parent i2web/components/form
   * @param {string} val Field value
   * @param {string} attr Attribute name
   * @description Validates all fields on the VM
   */
  validateSingle(val, attr) {
    if (attr) {
      const constraints = this.attr('constraints').attr(attr);
      if (constraints) {
        const serializedConstraints = constraints.serialize();

        // validate with all rules except equality, since we "hand validate" it.
        // we do this because there is no validate.single for equality (you have to pass both the source
        // and confirm fields), and we don't want the source field to be validated until it is visited
        delete serializedConstraints.equality;
        const errors = validate.single(val, serializedConstraints) || [];

        // if validating equality, we have to validate our field and the field we are comparing it to
        if (constraints.attr('equality')) {
          const relatedAttribute = constraints.attr('equality.attribute');
          if (val !== this.attr(relatedAttribute)) {
            if (constraints.attr('equality.message')) {
              errors.push(constraints.attr('equality.message').replace('^', ''));
            } else {
              errors.push(`is not equal to ${relatedAttribute}`);
            }
          }
        }
        if (errors.length) {
          // TODO remove replacement when . supported
          this.attr('_validationErrors').attr(attr.replace(/\./g, '__'), errors);
        } else {
          // TODO remove replacement when . supported
          this.attr('_validationErrors').removeAttr(attr.replace(/\./g, '__'));
        }
      }

      // if this field has other fields checking if they are "equal" to it, validate those as well.
      // this does not happen automatically with validate.single, so we have to manually trigger it.
      const equalityRelations = this.attr('_equalityRelations').attr(attr);
      if (equalityRelations) {
        each(equalityRelations, (relatedField) => {
          if (this.attr('_visited').attr(relatedField)) {
            this.validateSingle(this.attr(relatedField), relatedField);
          }
        });
      }
    }
  },
  /**
   * @function focusOnFirstError
   * @parent i2web/components/form
   * @description Moves document focus to the first invalid field in the form, if any; dependent on using
   * the templates in form-fields.js for input fields
   */
  focusOnFirstError() {
    const invalidField = this.attr('firstInvalidField');
    let focusTarget = document.querySelector(`[data-key="${invalidField}"]`);
    if (focusTarget) {
      if (focusTarget.type && focusTarget.type.startsWith('select')) {
        // Specific to our semantic-ui-dropdown application on SELECT input types
        const selectParent = focusTarget.parentElement;
        if (selectParent && selectParent.querySelector('input[class="search"]')) {
          focusTarget = selectParent.querySelector('input[class="search"]');
        }
      }
      focusTarget.focus();
    }
  },
  /**
   * @function hasChanges
   * @parent i2web/components/form
   * @param {Array<string>} [fields] (optional)
   * @return {Boolean} Whether the form (or specific fields) has changes to it
   */
  hasChanges(fields = []) {
    const fieldsWithChanges = canMap.keys(this.attr('_changed'));
    if (fields instanceof canList) {
      fields = fields.attr(); // eslint-disable-line no-param-reassign
    }
    if (Array.isArray(fields) && fields.length) {
      return _.some(fields, (field) => {
        return fieldsWithChanges.includes(field) && this.attr('_changed').attr(field);
      });
    }
    return this.attr('_anyFieldHasChanges');
  },
  /**
   * @function hasValidationErrors
   * @parent i2web/components/form
   * @param {Array<string>} [fields] (optional)
   * @return {Boolean} Whether the form (or specific fields) has validation errors on it
   */
  hasValidationErrors(fields = []) {
    const fieldsWithErrors = canMap.keys(this.attr('_validationErrors'));
    if (fields instanceof canList) {
      fields = fields.attr(); // eslint-disable-line no-param-reassign
    }
    if (Array.isArray(fields) && fields.length) {
      return _.some(fields, (field) => {
        // TODO remove replacement when . supported
        return fieldsWithErrors.includes(field.replace(/\./g, '__'));
      });
    }
    return !!(fieldsWithErrors.length);
  },
  /**
   * @function resetForm
   * @parent i2web/components/form
   * @description Resets the form to its original state
   */
  resetForm(ev) {
    if (ev) ev.stopPropagation();
    this.resetErrors();
    this.resetVisited();
    this.resetChanged();
    this.attr('_anyFieldHasChanges', false);
  },
  /**
   * @function resetErrors
   * @parent i2web/components/form
   *
   * @description Resets the errors on the form
   */
  resetErrors() {
    this.attr('formError', null);
    this.attr('_validationErrors', {});
  },
  /**
   * @function resetVisited
   * @parent i2web/components/form
   *
   * @description Resets the visited flag for each input field
   */
  resetVisited() {
    const changes = {};
    canMap.keys(this.attr('_visited')).forEach((key) => {
      changes[key] = false;
    });
    this.attr('_visited').attr(changes, false);
  },
  /**
   * @function resetChanged
   * @parent i2web/components/form
   *
   * @description Resets the changed flag for each input field
   */
  resetChanged() {
    const changes = {};
    canMap.keys(this.attr('_changed')).forEach((key) => {
      changes[key] = false;
    });
    this.attr('_changed').attr(changes, false);
  },
  /**
   * @function closePanel
   * @parent i2web/components/form
   *
   * @description Closes the panel
   */
  closePanel() {
    SidePanel.close();
  },
  /**
   * @function serializeData
   * @parent i2web/components/form
   *
   * @description return a plain js object with the data of this form serialized
   */
  serializeData() {
    const dataKeys = Object.keys(this.define).filter((k) => {
      return !k.startsWith('_')
        && k !== 'constraints'
        && k !== 'firstInvalidField';
    });

    return dataKeys.reduce((ret, key) => {
      ret[key] = this.attr(key);
      return ret;
    }, {});
  },
});

export const FormEvents = {
  // After the form submits, we need to blur it in order to hide
  // the soft keyboard on mobile devices.
  'form submit': function handleSubmit(el) {
    el.blur();
  },
  // listeners for validation
  // text inputs
  'input input': function handleInput(el) {
    const vmAttr = this.viewModel._convertFieldNameToDotNotation($(el).attr('{($value)}'));
    if (vmAttr) {
      if (this.viewModel.hasConstraints(vmAttr)) {
        this.viewModel.attr('_visited').attr({ [vmAttr]: true }, false);
      } else {
        canDev.log(vmAttr, 'doesn\'t have constraints and will not be flagged as visited.');
      }
      this.viewModel.attr('_changed').attr({ [vmAttr]: true }, false);
    } else {
      canDev.log(el, 'missing bound value (requires {($value)}) and will not be flagged as visited/changed.');
    }
    this.viewModel.attr('_anyFieldHasChanges', true);
  },
  'input blur': function handleBlur(el) {
    const vmAttr = this.viewModel._convertFieldNameToDotNotation($(el).attr('{($value)}'));
    if (vmAttr) {
      const value = $(el).val().trim();
      this.viewModel.attr(vmAttr, value);
      if (this.viewModel.hasConstraints(vmAttr)) {
        this.viewModel.attr('_visited').attr({ [vmAttr]: true }, false);
        this.viewModel.validateSingle(value, vmAttr);
      } else {
        canDev.log(vmAttr, 'doesn\'t have constraints and will not be flagged as visited nor validated.');
      }
    } else {
      canDev.log(el, 'missing bound value (requires {($value)}) and will not be flagged as visited nor validated.');
    }
  },
  // fix for IE11 not firing 'change' event when enter is pressed in an input
  // TODO: update to delegated enter event once https://github.com/canjs/can-util/issues/390 is resolved
  'input keyup': (el, ev) => {
    if (ev.keyCode === 13 || ev.key === 'Enter') {
      synthesizeIEChangeEvent(el);
    }
  },
  // selects
  'select change': function handleChange(el) {
    const vmAttr = this.viewModel._convertFieldNameToDotNotation($(el).attr('{($value)}'));
    if (vmAttr) {
      if (this.viewModel.hasConstraints(vmAttr)) {
        this.viewModel.attr('_visited').attr({ [vmAttr]: true }, false);
        this.viewModel.validateSingle($(el).val(), vmAttr);
      } else {
        canDev.log(vmAttr, 'doesn\'t have constraints and will not be flagged as visited nor validated.');
      }
      this.viewModel.attr('_changed').attr({ [vmAttr]: true }, false);
    } else {
      canDev.log(el, 'missing bound value (requires {($value)}) and will not be flagged as visited/changed nor validated.');
    }
    this.viewModel.attr('_anyFieldHasChanges', true);
  },
  // textareas
  'textarea input': function textAreaInput(el) {
    const vmAttr = this.viewModel._convertFieldNameToDotNotation($(el).attr('{($value)}'));
    if (vmAttr) {
      if (this.viewModel.hasConstraints(vmAttr)) {
        this.viewModel.attr('_visited').attr({ [vmAttr]: true }, false);
      } else {
        canDev.log(vmAttr, 'doesn\'t have constraints and will not be flagged as visited.');
      }
      this.viewModel.attr('_changed').attr({ [vmAttr]: true }, false);
    } else {
      canDev.log(el, 'missing bound value (requires {($value)}) and will not be flagged as visited/changed.');
    }
    this.viewModel.attr('_anyFieldHasChanges', true);
  },
  'textarea blur': function textAreaBlur(el) {
    const vmAttr = this.viewModel._convertFieldNameToDotNotation($(el).attr('{($value)}'));
    if (vmAttr) {
      const value = $(el).val().trim();
      this.viewModel.attr(vmAttr, value);
      if (this.viewModel.hasConstraints(vmAttr)) {
        this.viewModel.attr('_visited').attr({ [vmAttr]: true });
        this.viewModel.validateSingle(value, vmAttr);
      } else {
        canDev.log(vmAttr, 'doesn\'t have constraints and will not be flagged as visited nor validated.');
      }
    } else {
      canDev.log(el, 'missing bound value (requires {($value)}) and will not be flagged as visited nor validated.');
    }
  },
  // spinners
  [`arcus-spinner ${USE_TOUCH ? 'touchend' : 'mouseup'}`]: function spinner(el) {
    const vmAttr = this.viewModel._convertFieldNameToDotNotation($(el).attr('{(value)}'));
    if (vmAttr) {
      if (this.viewModel.hasConstraints(vmAttr)) {
        this.viewModel.attr('_visited').attr({ [vmAttr]: true }, false);
        this.viewModel.validateSingle(this.viewModel.attr(vmAttr), vmAttr);
      } else {
        canDev.log(vmAttr, 'doesn\'t have constraints and will not be flagged as visited nor validated.');
      }
      this.viewModel.attr('_changed').attr({ [vmAttr]: true }, false);
    } else {
      canDev.log(el, 'missing bound value (requires {(value)}) and will not be flagged as visited/changed nor validated.');
    }
    this.viewModel.attr('_anyFieldHasChanges', true);
  },
  // checkboxes
  'input[type="checkbox"] change': function checkboxChange(el) {
    const vmAttr = this.viewModel._convertFieldNameToDotNotation($(el).attr('{($checked)}'));
    if (vmAttr) {
      if (false && this.viewModel.hasConstraints(vmAttr)) { // eslint-disable-line no-constant-condition
        this.viewModel.attr('_visited').attr({ [vmAttr]: true }, false);
        this.viewModel.validateSingle($(el).is(':checked'), vmAttr);
      } else {
        canDev.warn('checkbox changed/visitation/validation not currently supported.');
      }
      // this.viewModel.attr('_changed').attr({ [vmAttr]: true }, false);
    } else {
      canDev.log(el, 'missing bound value (requires {($checked)}) and will not be flagged as visited/changed nor validated.');
    }
    // exclude accordion-toggle from changing the form
    if (!$(el).hasClass('accordion-toggle')) {
      this.viewModel.attr('_anyFieldHasChanges', true);
    }
  },
  // radio buttons
  'input[type="radio"] change': function radioChange(el) {
    const vmAttr = this.viewModel._convertFieldNameToDotNotation($(el).attr('{($checked)}'));
    if (vmAttr) {
      if (false && this.viewModel.hasConstraints(vmAttr)) { // eslint-disable-line no-constant-condition
        this.viewModel.attr('_visited').attr({ [vmAttr]: true }, false);
        this.viewModel.validateSingle(this.viewModel.attr(vmAttr), vmAttr);
      } else {
        canDev.warn('radio changed/visitation/validation not currently supported.');
      }
      // this.viewModel.attr('_changed').attr({ [vmAttr]: true }, false);
    } else {
      canDev.log(el, 'missing bound value (requires {($checked)}) and will not be flagged as visited/changed nor validated.');
    }
    this.viewModel.attr('_anyFieldHasChanges', true);
  },
  // _requiredFields changes
  '{viewModel} _requiredFields': function _requiredFields(vm, ev, newVal, oldVal) {
    const fieldsToReValidate = _.difference(newVal, oldVal).concat(_.difference(oldVal, newVal));
    fieldsToReValidate.forEach((field) => {
      // only validate if it's been visited before
      if (this.viewModel.attr('_visited').attr(field)) {
        this.viewModel.validateSingle(this.viewModel.attr(field), field);
      }
    });
  },
};

export const FormComponent = Component.extend({
  tag: 'arcus-form-base',
  events: FormEvents,
});
