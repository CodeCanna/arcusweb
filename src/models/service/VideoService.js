/**
 * Copyright 2019 Arcus Project
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import Bridge from 'i2web/cornea/bridge';

import Cornea from 'i2web/cornea/';

/**
 * @module {Object} i2web/models/VideoService VideoService
 * @parent app.models.services
 *
 * Entry points for video recordings.
 */
export default {
  /**
   * @function onRecordingsDeleted
   *
   * Emitted when all recordings for a place are deleted.
   *
   * @param {Function} callback Function to be executed upon recieving the event
   */
  onRecordingsDeleted(callback) {
    Cornea.on('video video:RecordingsDeleted', callback);
  },
  /**
   * @function onQuotaReport
   *
   * Emitted whenever quota is recalculated, this may not represent a change in quota, simply the current value.
   *
   * @param {Function} callback Function to be executed upon recieving the event
   */
  onQuotaReport(callback) {
    Cornea.on('video video:QuotaReport', callback);
  },
  /**
   * @function ListRecordings
   *
   * Lists all recordings available for a given place.
   *
   * @param {string} placeId UUID of the place.
   * @param {boolean} [all] List all recordings, including ones marked for deletion but not yet deleted
   * @param {enum} [type] Type of recording. Required to be one of the following ANY, STREAM, or RECORDING
   * @return {Promise}
   */
  ListRecordings(placeId, all, type) {
    return Bridge.request('video:ListRecordings', 'SERV:video:', {
      placeId,
      all,
      type,
    });
  },
  /**
   * @function PageRecordings
   *
   * Lists paged recordings available for a given place.
   *
   * @param {string} placeId UUID of the place.
   * @param {int} limit max number of recordings per page.
   * @param {string} token Token value to start the current page.  It should come from the nextToken value from the previous response.
   * @param {boolean} [all] Default: false If specified and set to true all recordings, including ones marked for deletion but not yet deleted will be returned
   * @param {boolean} [inprogress] Default: true If specified and set to false inprogress recordings / streams will not be shown.  Note that inprogress&#x3D;false AND type&#x3D;STREAM will always return an empty result.
   * @param {enum} [type] Type of recording.
ANY - Will return streams and recordings, this should not generally be used.
STREAM - Will return only streams, useful for attempting to piggy-back on an existing stream.
RECORDING - Will return only recordings, some may still be in progress and therefore missing information like duration.
   * @param {timestamp} [latest] No recordings that occur after this value will be returned. Since recordings are returned in descending order by time, recordings at the start of the list will be closer to this time.  Note if both token and latest are specified the earlier of the two values will be used.
   * @param {timestamp} [earliest] No recordings that occur before this value will be returned. Since recordings are returned in descending order by time, recordings at the end of the list will be closer to this time.
   * @param {set<String>} [cameras] Default: [] If specified, only recordings generated by the cameras in this set will be returned.  If not specified -or- the empty set, then all recordings will be returned regardless of camera.
   * @param {set<String>} [tags] Default: [] If specified, only recordings with *ANY* of the given tags will be included.  If not specified -or- the empty set, then all recordings will be returned regardless of tags.
   * @return {Promise}
   */
  PageRecordings(placeId, limit, token, all, inprogress, type, latest, earliest, cameras, tags) {
    return Bridge.request('video:PageRecordings', 'SERV:video:', {
      placeId,
      limit,
      token,
      all,
      inprogress,
      type,
      latest,
      earliest,
      cameras,
      tags,
    });
  },
  /**
   * @function StartRecording
   *
   * Starts a video recording or live streaming session.
   *
   * @param {string} placeId UUID of the place.
   * @param {string} accountId UUID of the account.
   * @param {string} cameraAddress UUID of the camera.
   * @param {boolean} stream True to start live streaming, false to start recording.
   * @param {int} [duration] The duration to record in seconds.  If not provided the default duration of 20 minutes will be used
   * @return {Promise}
   */
  StartRecording(placeId, accountId, cameraAddress, stream, duration) {
    return Bridge.request('video:StartRecording', 'SERV:video:', {
      placeId,
      accountId,
      cameraAddress,
      stream,
      duration,
    });
  },
  /**
   * @function StopRecording
   *
   * Stops a video recording or live streaming session.
   *
   * @param {string} placeId UUID of the place.
   * @param {string} recordingId UUID of the recording.
   * @return {Promise}
   */
  StopRecording(placeId, recordingId) {
    return Bridge.request('video:StopRecording', 'SERV:video:', {
      placeId,
      recordingId,
    });
  },
  /**
   * @function GetQuota
   *
   * Gets the video storage quota for a place.
   *
   * @param {string} placeId UUID of the place.
   * @return {Promise}
   */
  GetQuota(placeId) {
    return Bridge.request('video:GetQuota', 'SERV:video:', {
      placeId,
    });
  },
  /**
   * @function GetFavoriteQuota
   *
   * Gets the video favorite video quota for a place.
   *
   * @param {string} placeId UUID of the place.
   * @return {Promise}
   */
  GetFavoriteQuota(placeId) {
    return Bridge.request('video:GetFavoriteQuota', 'SERV:video:', {
      placeId,
    });
  },
  /**
   * @function DeleteAll
   *
   * Delete all recordings for the given place.
   *
   * @param {string} placeId UUID of the place
   * @param {boolean} [includeFavorites] True if favorite recordings should be deleted also.
   * @return {Promise}
   */
  DeleteAll(placeId, includeFavorites) {
    return Bridge.request('video:DeleteAll', 'SERV:video:', {
      placeId,
      includeFavorites,
    });
  },
};
